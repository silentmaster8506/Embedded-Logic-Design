#include <stdio.h>
#include <complex.h>
#include <stdlib.h>
#include <math.h>

#include "platform.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include "xtime_l.h"

#include "xparameters.h"
#include "xaxidma.h"

#ifndef XPAR_AXI_DMA_0_DEVICE_ID
#define XPAR_AXI_DMA_0_DEVICE_ID XPAR_AXIDMA_0_DEVICE_ID
#endif

#define N 8    // 8-Point FFT

// Align buffers to cache lines (64 bytes) for safe DMA operations
static float complex FFT_input[N] __attribute__ ((aligned (64))) = {
    11+23*I, 32+10*I, 91+94*I, 15+69*I,
    47+96*I, 44+12*I, 96+17*I, 49+58*I
};

static float complex FFT_output_sw[N] __attribute__ ((aligned (64)));
static float complex FFT_output_hw[N] __attribute__ ((aligned (64)));
static float complex FFT_rev_sw[N]    __attribute__ ((aligned (64)));

// ---------------- BIT REVERSE TABLE (8-POINT) ----------------
static const int rev8[N] = {
    0, 4, 2, 6,
    1, 5, 3, 7
};

// ---------------- TWIDDLE FACTORS FOR N = 8 -------------------
static const float complex W[N/2] = {
    1.00000000 - 0.00000000*I,
    0.70710678 - 0.70710678*I,
    0.00000000 - 1.00000000*I,
   -0.70710678 - 0.70710678*I
};

// ---------------- SOFTWARE HELPER FUNCTIONS ----------------
void bitreverse(float complex in[N], float complex out[N])
{
    for (int i = 0; i < N; i++)
        out[i] = in[rev8[i]];
}

void FFT_stages(float complex in[N], float complex out[N])
{
    float complex t1[N], t2[N];

    // Stage 1
    for (int i = 0; i < N; i += 2) {
        t1[i]   = in[i] + in[i+1];
        t1[i+1] = in[i] - in[i+1];
    }

    // Stage 2
    for (int i = 0; i < N; i += 4) {
        t2[i]   = t1[i] + W[0] * t1[i+2];
        t2[i+2] = t1[i] - W[0] * t1[i+2];

        t2[i+1] = t1[i+1] + W[2] * t1[i+3];
        t2[i+3] = t1[i+1] - W[2] * t1[i+3];
    }

    // Stage 3
    for (int i = 0; i < 4; i++) {
        out[i]   = t2[i] + W[i] * t2[i+4];
        out[i+4] = t2[i] - W[i] * t2[i+4];
    }
}

int DMA_Init(XAxiDma *AxiDma, u16 DeviceId)
{
    XAxiDma_Config *CfgPtr;
    CfgPtr = XAxiDma_LookupConfig(DeviceId);
    if (!CfgPtr) {
        xil_printf("No config found\n");
        return XST_FAILURE;
    }

    int Status = XAxiDma_CfgInitialize(AxiDma, CfgPtr);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    if(XAxiDma_HasSg(AxiDma)) return XST_FAILURE;

    XAxiDma_IntrDisable(AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrDisable(AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

    return XST_SUCCESS;
}

// =======================================================================
// MAIN
// =======================================================================

int main()
{
    init_platform();

    XAxiDma AxiDMA;
    int status;

    // Timing variables
    XTime ps_start, ps_end;
    XTime pl_start, pl_end;

    xil_printf("\n--- Starting 8-point FFT + 1/(1.5 + FFT(x)) Test ---\n");

    // =============================================================
    // PART A: SOFTWARE (PS)
    // =============================================================

    // Start Clock
    XTime_GetTime(&ps_start);

    // 1. Perform standard FFT
    bitreverse(FFT_input, FFT_rev_sw);
    FFT_stages(FFT_rev_sw, FFT_output_sw);

    // 2. Apply Post-Processing: y = 1 / (1.5 + x)
    for(int i = 0; i < N; i++) {
        float complex temp = FFT_output_sw[i] + 1.5f;
        FFT_output_sw[i] = 1.0f / temp;
    }

    // Stop Clock
    XTime_GetTime(&ps_end);

    // =============================================================
    // PART B: HARDWARE (PL)
    // =============================================================

    status = DMA_Init(&AxiDMA, XPAR_AXI_DMA_0_DEVICE_ID);
    if (status != XST_SUCCESS) {
        xil_printf("DMA init failed!\n");
        return -1;
    }

    // Flush cache so DMA reads fresh Input data from RAM
    Xil_DCacheFlushRange((UINTPTR)FFT_input, sizeof(FFT_input));
    Xil_DCacheFlushRange((UINTPTR)FFT_output_hw, sizeof(FFT_output_hw));

    // Start Clock
    XTime_GetTime(&pl_start);

    // 1. Start RX (Device -> Memory)
    status = XAxiDma_SimpleTransfer(
        &AxiDMA,
        (UINTPTR)FFT_output_hw,
        sizeof(FFT_output_hw),
        XAXIDMA_DEVICE_TO_DMA
    );
    if (status != XST_SUCCESS) return -1;

    // 2. Start TX (Memory -> Device)
    status = XAxiDma_SimpleTransfer(
        &AxiDMA,
        (UINTPTR)FFT_input,
        sizeof(FFT_input),
        XAXIDMA_DMA_TO_DEVICE
    );
    if (status != XST_SUCCESS) return -1;

    // Wait for completion
    while (XAxiDma_Busy(&AxiDMA, XAXIDMA_DMA_TO_DEVICE));
    while (XAxiDma_Busy(&AxiDMA, XAXIDMA_DEVICE_TO_DMA));

    // Stop Clock
    XTime_GetTime(&pl_end);

    // Invalidate cache to read fresh HW results from RAM
    Xil_DCacheInvalidateRange((UINTPTR)FFT_output_hw, sizeof(FFT_output_hw));

    // =============================================================
    // PART C: COMPARISON & REPORTING
    // =============================================================
    printf("\nComparing PS vs PL:\n");

    int error_count = 0;

    for (int i = 0; i < N; i++) {
        float diff_r = fabs(crealf(FFT_output_sw[i]) - crealf(FFT_output_hw[i]));
        float diff_i = fabs(cimagf(FFT_output_sw[i]) - cimagf(FFT_output_hw[i]));

        // Print only mismatches or first few to keep console clean
        printf("Idx %d | PS %.4f%+.4fi | PL %.4f%+.4fi",
               i,
               crealf(FFT_output_sw[i]), cimagf(FFT_output_sw[i]),
               crealf(FFT_output_hw[i]), cimagf(FFT_output_hw[i]));

        if (diff_r > 0.001 || diff_i > 0.001) {
            printf(" -> MISMATCH\n");
            error_count++;
        } else {
            printf(" -> MATCH\n");
        }
    }

    printf("\n--------------------------------------------\n");
    printf("FINAL RESULT: %s\n", (error_count == 0) ? "SUCCESS" : "FAIL");
    printf("--------------------------------------------\n");

    // Calculate duration in microseconds
    // COUNTS_PER_SECOND is defined in xtime_l.h (usually CPU_FREQ / 2)
    double ps_time_us = 1000000.0 * (double)(ps_end - ps_start) / (double)COUNTS_PER_SECOND;
    double pl_time_us = 1000000.0 * (double)(pl_end - pl_start) / (double)COUNTS_PER_SECOND;

    printf("Execution Time Summary:\n");
    printf("PS (Software) Time : %.2f us\n", ps_time_us);
    printf("PL (Hardware) Time : %.2f us\n", pl_time_us);
    printf("--------------------------------------------\n");

    cleanup_platform();
    return 0;
}
